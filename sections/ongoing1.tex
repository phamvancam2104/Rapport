\section{Ongoing and future work}
\label{sec:ongoing-future}
\subsection{Towards synchronization of UML State Machine and programming languages}
\subsubsection{Problem statement}
\begin{itemize}
	\item Although code generation from UML State Machine is proposed by multiple approaches, a complete generation solution is not achieved yet (see \ref{subsec:majors}). Furthermore, none of existing code generators allows round-trip engineering or synchronization. This is, as previously discussed, one of the reasons why software development practitioners are reluctant to adopt MDE into practice.
	
	\item Synchronization of UML State Machine and code is hard, even impossible in case of resource constraints since one-to-one mappings from UML State Machine concepts to code statements are hard to achieve. Even, in simple cases where only states and transitions are used, the generated code size has a slightly larger memory overhead (see \ref{subsec:usm2code}) compared to traditional approaches such as if/else or nested switch statements.  
\end{itemize}

\subsubsection{Idea overview}
\paragraph{\tb{General idea}} ~\\
The general idea is to provide a mechanism from which software engineering stakeholders can profit in practice, e.g. software architects work with diagram-based languages while programmers are productive with text-based languages. 
This study is the realization of the approach in Fig. \ref{fig:smapproaches}.
To do it, A text-based domain specific language is proposed. This proposed language is descriptive and seamlessly integrated with diagrams and programming languages. 
The idea is inspired by the model-oriented programming language \ti{Umple}\footnote{Umple, \url{http://cruise.eecs.uottawa.ca/umple/}}. 
The purpose of the proposed language is to provide a text-based DSL compliant to the UML State Machine specification, which is not correctly defined by Umple.  

The language allows programmers productively write \tb{UML-compliant and complete state machines} without restrictions in a textual way. 
\tb{UML-compliance and completeness} focus on the full support for UML State Machine features and the semantics of generated code, and are key characteristics used to differentiate this proposed language from other non UML-compliant languages such as Umple and ThingML\footnote{ThingML, \url{http://thingml.org/}}. 
This proposed language is synchronized with UML State Machine in diagrammatic forms by using the generic pattern proposed in Section \ref{sec:processes}. Generated code with full UML State Machine features is achieved by using the generation solution in Section \ref{sec:codegen}. 
This language is a convergence of the generic pattern and the complete code generation to provide an efficient and productive way to develop reactive, real-time and embedded systems.


\paragraph{\tb{Advantages}} ~\\
Followings are advantages of this proposition:
\begin{itemize}
	\item Software architects are freely to describe the behavior of systems by using state machine diagrams.
	
	\item Programmers are freely to work with a text-based environment to be productive.
	
	\item State machines used for generating code are not restricted to simple or non-concurrent cases as in other approaches.
	
	\item At anytime, generated code and software architects-built diagrams are consistent by using the generic synchronization pattern.
\end{itemize}

\subsection{Verification of semantic-conformance of generated code runtime execution}
UML State Machine and its visualizations are widely used for modeling and designing real-time embedded systems. Although many existing approaches can generate code from state machines, the semantic conformance of runtime execution of generated code is not verified yet. The goal of this study is to provide a verification of code generated by the above generation approach. 

Two approaches can be candidates for the verification. The first is to use bi-simulation (see Fig. 
\ref{fig:bisimu}), in which a state machine is simulated by the MOKA engine \cite{moka}, which is a model simulator and offers PSSM. The same state machine is also used for generating code, which is compiled and executed. The execution traces obtained from the simulation and execution are then compared to each other. Generated code for a given state machine is considered semantic-conformant, within the scope of PSSM, if both of the traces are identical. Existing approaches had little chance to do the verification since PSSM is very new.
The second one is to utilize model checking techniques, which model checks the generated code conforming to a specification, which is transformed from the state machine.

\begin{figure}
	\centering
	\includegraphics[trim={0.0cm 8.5cm 16.6cm 6.5cm},clip, width=\columnwidth]{figures/semanticconformance}
	\caption{Bi-simulation to test the semantic-conformance of generated code runtime execution}
	\label{fig:bisimu}
\end{figure}